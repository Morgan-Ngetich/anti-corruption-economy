# `anti-corruption-economy`

Welcome to your new `anti-corruption-economy` project and to the Internet Computer development community. By default, creating a new project adds this README and some template files to your project directory. You can edit these template files to customize your project and to include your own code to speed up the development cycle.

To get started, you might want to explore the project directory structure and the default configuration file. Working with this project in your development environment will not affect any production deployment or identity tokens.

To learn more before you start working with `anti-corruption-economy`, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally)
- [SDK Developer Tools](https://internetcomputer.org/docs/current/developer-docs/setup/install)
- [Rust Canister Development Guide](https://internetcomputer.org/docs/current/developer-docs/backend/rust/)
- [ic-cdk](https://docs.rs/ic-cdk)
- [ic-cdk-macros](https://docs.rs/ic-cdk-macros)
- [Candid Introduction](https://internetcomputer.org/docs/current/developer-docs/backend/candid/)

If you want to start working on your project right away, you might want to try the following commands:

```bash
cd anti-corruption-economy/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor




# Anti-Corruption Economy: Building Transparency and Incentives

## Introduction

The Anti-Corruption Economy project aims to combat corruption through transparency and active participation. This application encourages users to report corruption incidents, engage in anti-corruption efforts, and stay informed about corruption-related issues. By leveraging AI, the project provides a sophisticated and user-friendly platform to enhance the fight against corruption.

## Features

1. **Introduction:**
   - **Purpose of the App:** Combating corruption through transparency and active participation.
   - **Call to Action:** Encourage users to report corruption incidents or engage in anti-corruption efforts.
   - **Featured Cases:** Highlight successful cases where corruption was exposed or prevented.
   - **Statistics:** Display relevant statistics (e.g., reports submitted, convictions).
   - **Testimonials:** Share quotes from users or officials supporting the app.

2. **Reporting:**
   - **Form:** Provide a user-friendly form for reporting corruption incidents.
   - **Anonymity:** Assure users of anonymity and data privacy.
   - **Guidelines:** Include guidelines on what constitutes corruption and how to report it.
   - **Upload Evidence:** Allow users to attach evidence (documents, images).

3. **Educational Content:**
   - **Articles, Videos, and Infographics:** Understanding corruption.
   - **Legal Framework:** Explain relevant laws and regulations related to corruption.
   - **Prevention Tips:** Provide guidance on preventing corruption in various contexts.

4. **Financial Transparency:**
   - **Show Fund Allocation:** Show how funds are allocated and spent.
   - **Public Officials:** List public officials' declarations of assets and interests.
   - **Project Tracking:** Display progress on anti-corruption initiatives.

5. **Community Involvement:**
   - **Volunteer Opportunities:** Offer ways for users to actively participate.
   - **Join Campaigns:** Promote anti-corruption campaigns and events.
   - **Donate:** Enable donations to support app development and outreach.

6. **Token Economy:**
   - **Earn Tokens:** Users earn tokens by reporting corruption, providing evidence, attending workshops, or volunteering.
   - **Gift Tokens:** Users can gift tokens to others as recognition or encouragement.
   - **Withdrawal Mechanism:** Users can convert earned tokens to real-world currency (ICP or ICPEx).
   - **Transaction History:** Transparent transaction history.

7. **Leveraging AI:**
   - **AI-Based Reporting Assistance:** An AI chatbot to guide users through the reporting process using NLP.
   - **AI Analysis and Alerts:** Analyze submitted reports for patterns and anomalies using ML algorithms.
   - **Personalized Educational Content:** Recommend educational content based on user behavior and interests using AI.
   - **Automated Moderation:** Automatically flag and prioritize reports for review using AI models.
   - **Predictive Analytics:** Predict future corruption hotspots and trends using predictive modeling.

## File and Folder Structure

```plaintext
anti-corruption-economy/
├── src/
│   ├── anti_corruption_canister/
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   └── ...
│   │   ├── Cargo.toml
│   │   └── ...
│   ├── ai/
│   │   ├── models/
│   │   │   ├── nlp_model.pkl
│   │   │   ├── anomaly_detection_model.pkl
│   │   │   └── ...
│   │   ├── scripts/
│   │   │   ├── nlp_processing.py
│   │   │   ├── anomaly_detection.py
│   │   │   ├── content_recommendation.py
│   │   │   ├── moderation.py
│   │   │   ├── predictive_analytics.py
│   │   │   └── ...
│   │   ├── services/
│   │   │   ├── ai_service.py
│   │   │   └── ...
│   │   ├── __init__.py
│   │   └── requirements.txt
│   ├── assets/
│   ├── declarations/
│   ├── src/
│   │   ├── components/
│   │   │   ├── navbar/
│   │   │   │   └── Navbar.jsx
│   │   │   ├── footer/
│   │   │   │   └── Footer.jsx
│   │   │   ├── dashboard/
│   │   │   │   └── Dashboard.jsx
│   │   │   ├── report_corruption/
│   │   │   │   └── ReportForm.jsx
│   │   │   ├── view_reports/
│   │   │   │   └── ViewReports.jsx
│   │   │   ├── educational_resources/
│   │   │   │   └── EducationalResources.jsx
│   │   │   ├── transparency/
│   │   │   │   └── Transparency.jsx
│   │   │   ├── community/
│   │   │   │   └── Community.jsx
│   │   │   ├── wallet/
│   │   │   │   └── Wallet.jsx
│   │   │   ├── chatbot/
│   │   │   │   └── Chatbot.jsx
│   │   │   └── ...
│   │   ├── pages/
│   │   │   ├── HomePage.jsx
│   │   │   └── ...
│   │   ├── App.js
│   │   ├── index.js
│   │   └── ...
│   ├── dfx.json
│   ├── Cargo.toml
│   └── ...
└── ...
```

# Explanation of the Structure

### `anti_corruption_canister/`
Contains the backend logic for the application written in Rust.

- **`src/`**: Source code for the Rust canister.
- **`Cargo.toml`**: Configuration file for the Rust project.

### `ai/`
Contains AI-related scripts, models, and services.

- **`models/`**: Pre-trained AI models used in the project.
- **`scripts/`**: Python scripts for various AI functionalities.
  - **`nlp_processing.py`**: Script for natural language processing tasks.
  - **`anomaly_detection.py`**: Script for detecting anomalies in reports.
  - **`content_recommendation.py`**: Script for recommending educational content.
  - **`moderation.py`**: Script for automated moderation of reports.
  - **`predictive_analytics.py`**: Script for predictive analytics on corruption trends.
- **`services/`**: Python services to handle AI-related endpoints.
  - **`ai_service.py`**: Service to interact with AI scripts and models.

### `assets/`
Static assets like images, icons, and stylesheets.

### `declarations/`
Declarations for the project.

### `src/`
Contains the frontend source code.

- **`components/`**: React components used in the application.
  - **`navbar/`**: Navbar component.
  - **`footer/`**: Footer component.
  - **`dashboard/`**: Dashboard component.
  - **`report_corruption/`**: Components for reporting corruption.
  - **`view_reports/`**: Components for viewing reports.
  - **`educational_resources/`**: Components for educational resources.
  - **`transparency/`**: Components for financial transparency.
  - **`community/`**: Components for community involvement.
  - **`wallet/`**: Components for the token wallet.
  - **`chatbot/`**: Components for the AI chatbot.
- **`pages/`**: Page components for the application.
  - **`HomePage.jsx`**: Home page of the application.
- **`App.js`**: Main application file.
- **`index.js`**: Entry point for the React application.

### `dfx.json`
Configuration file for DFINITY's Internet Computer framework.

### `Cargo.toml`
Configuration file for the Rust project.



# Git Flow Branching Model

We use Git Flow for managing our branching and release process. Below is the information for branch names and prefixes used in the project.

### Branches

1. **Main Branch**
   - **Branch Name**: `main`
   - **Purpose**: This is the branch for production releases. All code in this branch should be stable and ready for deployment.

2. **Development Branch**
   - **Branch Name**: `develop`
   - **Purpose**: This is the branch for the next release development. Features and bug fixes are merged into this branch before they are ready for production.

### Supporting Branches

1. **Feature Branches**
   - **Prefix**: `feature/`
   - **Purpose**: Used for developing new features. Branch off from `develop` and merge back into `develop` when the feature is complete.

2. **Bugfix Branches**
   - **Prefix**: `bugfix/`
   - **Purpose**: Used for fixing bugs in the code. Branch off from `develop` and merge back into `develop` once the bug is fixed.

3. **Release Branches**
   - **Prefix**: `release/`
   - **Purpose**: Used for preparing a new production release. Branch off from `develop` and merge into both `main` and `develop` when the release is ready.

4. **Hotfix Branches**
   - **Prefix**: `hotfix/`
   - **Purpose**: Used for urgent fixes to the production code. Branch off from `main` and merge back into both `main` and `develop` when the fix is complete.

5. **Support Branches**
   - **Prefix**: `support/`
   - **Purpose**: Used for maintaining old versions or providing support for specific versions.

### Version Tag Prefix

- **Prefix**: `v`
- **Purpose**: Tags for version releases are prefixed with `v`, e.g., `v1.0.0`.

## How to Use Git Flow

1. **Initialize Git Flow**
   - Run `git flow init` to set up the branching model in your repository.

2. **Create a New Feature**
   - Use `git flow feature start <feature-name>` to create a new feature branch.
   - After completing the feature, use `git flow feature finish <feature-name>` to merge it into `develop`.

3. **Create a New Bugfix**
   - Use `git flow bugfix start <bugfix-name>` to create a new bugfix branch.
   - After fixing the bug, use `git flow bugfix finish <bugfix-name>` to merge it into `develop`.

4. **Create a New Release**
   - Use `git flow release start <version>` to create a release branch.
   - After preparing the release, use `git flow release finish <version>` to merge it into `main` and `develop`.

5. **Create a Hotfix**
   - Use `git flow hotfix start <hotfix-name>` to create a hotfix branch.
   - After applying the hotfix, use `git flow hotfix finish <hotfix-name>` to merge it into `main` and `develop`.

6. **Create a Support Branch**
   - Use `git flow support start <support-name>` to create a support branch.

By following these guidelines, we ensure a consistent and organized workflow for managing our codebase, releases, and hotfixes.